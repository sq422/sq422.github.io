---
title: Redis基础篇
tags:
    - Redis
    - 缓存中间件
categories:
    - Redis
description: 介绍了Redis相关的一些基础知识
date: 2026-1-08T18:00:00+08:00
updated: 2026-1-08T18:00:00+08:00
# 文章的永久链接
abbrlink: abc102
---
<!-- &emsp;&emsp;表示两个空格 -->
# **Redis基础知识**
1. 1.*对redis的了解，以及它的优缺点*：
    - redis是一款基于内存的非关系型数据库，它的优点就是快，因为它是纯内存操作，所以读写效率高，
同时它还是单线程模型，避免了多线程之间的切换开销，且无需复杂的锁机制来保障线程安全，指令执行效率也高。
2. 2.*Redis中常用的数据结构*：
    - String：用来存储单个简单值，比如说用作计数器（自增/自减），或用作分布式锁。
    - Hash：用来存储复杂的对象。
    - List：用来存储多个值，常用作消息队列。
    - Set：用来存储不重复的多个值，常用作标签系统、共同好友。
    - Zset：用来存储不重复的多个值，且天然有序，常用来做排行榜、热门标签等应用。
3. 3.*String和Hash的区别*：
    - String：用来存储单个简单值，string值不可变，每次修改都会创建新的对象，常用作计数器或分布式锁。
    - Hash：用来存储对象，Hash值可变，可直接修改内部字段。
4. 4.*Set和Zset的区别*：
    - 相同点：它们都是set集合，用来存储不重复的元素。
    - 区别：但是Zset是有序集合，它的内部的每个元素都关联着一个分数，并按照分数大小进行排序（默认是从小到大）。所以Zset还具有许多基于分数的操作，比如说对元素的分数进行加减来影响它的排序，或者根据分数范围来进行范围查找。
5. 5.*Zset的底层是怎么实现的*：
    - 当Zset内部元素个数小于128个，且每个元素小于64字节时，Zset会使用压缩列表作为底层数据结构，否则就会使用跳表作为底层数据结构。
6. 6.*跳表是怎么实现的*：
    - 介绍：跳表是一种基于链表的数据结构，它通过在底层链表的节点上添加多层索引来达到加速搜索的效果。
    - 具体实现：跳表的底层是一条有序的双向链表，上层结点是下层链表的子节点，子节点之间的距离就是高层搜索时可以跳过的距离，
    通过这种方式就可以快速跳过一些无效结点，从而进行高效查找。
    - 特点：优点就是实现简单，时间复杂度低，缺点是需要额外的索引，空间复杂度高
7. 7.*跳表是怎么设置层高的*：
    - 对于跳表而言，它的初始层高为1，在插入新节点时会生成一个[0,1]区间的随机数，当这个随机数小于0.25时，这个新节点就会增加一层高度，
    然后继续生成随机数进行判定，直到这个随机数大于0.25后确定层高。
8. 8.*压缩列表的实现原理*：
    - 压缩列表是由连续内存块组成的顺序型数据结构，它与数组的区别在于它的每个元素的内存大小可能不同。压缩列表中有四个固定元素： 

    | 字段名 | 作用 |
    |:------|:-----:|
    |zlbytes|代表整个压缩列表的总字节数|
    |zltail|表示从zlbytes起始地址开始到尾结点的偏移量（可以反向遍历）|
    |zllen|记录压缩列表数据节点的个数|
    |zlend|标记压缩列表的结束点|

    - 每个数据节点由三部分组成：

    | 字段名 | 作用 |
    |:------|:-----:|
    |prevrawlen|前一个节点的长度，用于反向遍历|
    |len|当前节点的长度|
    |data|结点存放的数据|
    - 压缩列表通过节点的长度计算偏移量来访问数据
9. 9.*介绍一下listpack*：
    - listpack是Redis用来替代压缩列表的数据结构，它相较于压缩列表的最大特点是每个节点中不再保存前一个节点的长度，这样就可以避免压缩列表中会出现的连锁更新的问题。（更新完一个结点后可能需要更新后面多个结点）
10. 10.*Redis的ZSet为什么使用跳表而非B+树*：
    - B+树的作用主要是通过降低树高来减少磁盘IO次数，但是为了维护树高的平衡在增删数据后可能会进行分裂或合并操作，维护成本高。
    - 而Redis是纯内存操作，基本不会和磁盘交互，所以没必要使用复杂的B+树，使用简单的跳表结构就能实现同等级别的性能。
11. 11.Redis中Hash表的扩容原理：
    - 首先会创建一个新的Hash表并分配内存空间，大小为原来容量的两倍
    - 然后将原来Hash表的数据迁移到新的Hash表中
    - 迁移完成后释放原来的Hash表内存，并将索引指向新的Hash表
12. 12.Redis中Hash表的扩容时的数据迁移过程：
    - （1.）在redis中hash表扩容时的数据迁移是一种渐进式rehash，它不是直接拷贝原数据，因为这样会导致长时间堵塞。
    - （2.）渐进式rehash指的是Hash表在rehash过程中:
        - > 每次对hash表进行读操作时，先到原hash表中进行查询，如果找到了那么在读操作完成后会将原表中的元素移动到新表中，找不到了再到新hash表中进行查询。
        - > 写操作时，则是直接将值写入新表中
        - > 更新操作会先删除原表中的元素，然后把新值写入新表中
        - > 删除操作会查询两个表进行删除
    - （3.）这样就保证了原表中的数据只减不增，最终变为空表时就可以直接释放内存。
13. 13.*Redis中String是怎么储存的*：
    - redis中string采用SDS数据结构进行存储：
        - len：用来记录当前字符串的长度。
        - alloc：用来记录当前字符串分配到内存大小，当字符串修改后大小不够时会自动拓展内存。
        - flags：用来记录SDS数据结构的类型。
        - buf[]：用来记录保存到数据。
14. 14.*Redis字符串对C语言字符串的优化*：
    - （1.）获取字符串长度更简单：c语言中需要遍历字符串来获取长度，redis中则可以直接通过len字段获取。
    - （2.）二进制安全：c语言中依赖于'\0'来作为结束标识，当保存的数据中存在这个符号时可能会产生数据截断，而redis的字符串中明确的知道字符串的长度，因此不会发生这个问题。
    - （3.）不会发生缓冲区溢出：当缓冲区内存不足时，redis的string会根据alloc字段来进行自动扩容。
15. 15.*Redis事务*：
    - Redis的命令执行是单线程的，具有原子性。
    - Redis的事务就是把命令打包起来执行，不能回滚。
16. 16.*Redis持久化*：
    - （1.）RDB快照持久化：将数据库的数据信息压缩成二进制RDB文件存储在磁盘中，这种方式存在一个问题，就是在备份后到下一次备份前的数据可能会丢失。
    - （2.）AOF文件追加持久化：这种方式是在服务启动后将所有写指令都以aof文件的方式存储到磁盘中，当数据丢失后通过重新执行一遍写操作来恢复数据。
    - （3.）混合方式：在数据库刚开始启动时使用RDB进行一次备份，然后在服务运行过程中通过AOF方式进行备份。
    - （4.）RDB与AOF之间的比较：
        - RDB方式存储的文件体积小，数据恢复速度快，但是安全性较低。
        - AOF方式存储的文件体积大，数据恢复速度慢，但是安全性更高，且可读性更强。
    - （5.）Redis针对于AOF文件过大的优化是AOF重写：对于key的写操作，aof重写会丢弃冗余命令、过滤无效命令，仅保留有效写操作。
        - 比如说对于string类型的key，aof重写只会保留一条这个key的最终值的写入操作。
        - 对于hash、list、set类型的key会将所有写命令整合成一条批量操作命令，比如说多次hset合并成HMset批量插入。
        - 且aof重写不会记录运行过程中被删除或者过期的key